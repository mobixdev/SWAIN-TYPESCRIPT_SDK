/* tslint:disable */
/* eslint-disable */
/**
 * SWAIN API
 * A powerful dynamic CRUD API engine that automatically generates RESTful endpoints for your data models SWAIN provides automatic CRUD operations, filtering, pagination, and sorting capabilities for any data model. Features: - Automatic REST API generation - Dynamic model support - Complex filtering and querying - Pagination and sorting - Swagger/OpenAPI documentation - Multiple database support (SQL & NoSQL)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
import type { QuerySortSpec } from './QuerySortSpec';
import {
    QuerySortSpecFromJSON,
    QuerySortSpecFromJSONTyped,
    QuerySortSpecToJSON,
    QuerySortSpecToJSONTyped,
} from './QuerySortSpec';
import type { QueryAggregationSpec } from './QueryAggregationSpec';
import {
    QueryAggregationSpecFromJSON,
    QueryAggregationSpecFromJSONTyped,
    QueryAggregationSpecToJSON,
    QueryAggregationSpecToJSONTyped,
} from './QueryAggregationSpec';

/**
 * Filter conditions for querying entities using complex expressions Supports logical operations (AND, OR, NOT), field comparisons, and relationship filtering Example: { "expressions": [ {"field": "age", "operator": "gte", "value": 18}, { "operator": "AND", "expressions": [ {"field": "status", "operator": "eq", "value": "active"} ] } ] }
 * @export
 * @interface QueryFilter
 */
export interface QueryFilter {
    /**
     * @Description Aggregations can specify functions like COUNT, SUM, GROUP BY, etc.
     * @Description If not provided, no aggregations will be performed.
     * @Description Used for data analysis and reporting queries
     * @type {QueryAggregationSpec}
     * @memberof QueryFilter
     */
    aggregations?: QueryAggregationSpec;
    /**
     * @Description Array of expressions to filter entities
     * @Description Each expression can be a FieldExpression, LogicalExpression, or RelationshipExpression
     * @Description If empty, no filtering will be applied
     * @type {Array<object>}
     * @memberof QueryFilter
     */
    expressions?: Array<object>;
    /**
     * @Description Array of field names to select from the main entity
     * @Description If empty, all fields will be selected
     * @Description Example: ["id", "name", "email"] to select only those fields
     * @type {Array<string>}
     * @memberof QueryFilter
     */
    projections?: Array<string>;
    /**
     * @Description Array of sort specifications to order the results
     * @Description Example: [{"field": "name", "direction": "asc"}, {"field": "createdAt", "direction": "desc"}]
     * @Description Field names can be struct field names or database column names. Direction is case-insensitive ('asc' or 'desc').
     * @type {Array<QuerySortSpec>}
     * @memberof QueryFilter
     */
    sort?: Array<QuerySortSpec>;
}

/**
 * Check if a given object implements the QueryFilter interface.
 */
export function instanceOfQueryFilter(value: object): value is QueryFilter {
    return true;
}

export function QueryFilterFromJSON(json: any): QueryFilter {
    return QueryFilterFromJSONTyped(json, false);
}

export function QueryFilterFromJSONTyped(json: any, ignoreDiscriminator: boolean): QueryFilter {
    if (json == null) {
        return json;
    }
    return {
        
        'aggregations': json['aggregations'] == null ? undefined : QueryAggregationSpecFromJSON(json['aggregations']),
        'expressions': json['expressions'] == null ? undefined : json['expressions'],
        'projections': json['projections'] == null ? undefined : json['projections'],
        'sort': json['sort'] == null ? undefined : ((json['sort'] as Array<any>).map(QuerySortSpecFromJSON)),
    };
}

export function QueryFilterToJSON(json: any): QueryFilter {
    return QueryFilterToJSONTyped(json, false);
}

export function QueryFilterToJSONTyped(value?: QueryFilter | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }

    return {
        
        'aggregations': QueryAggregationSpecToJSON(value['aggregations']),
        'expressions': value['expressions'],
        'projections': value['projections'],
        'sort': value['sort'] == null ? undefined : ((value['sort'] as Array<any>).map(QuerySortSpecToJSON)),
    };
}

