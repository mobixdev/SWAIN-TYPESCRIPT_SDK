/* tslint:disable */
/* eslint-disable */
/**
 * SWAIN API
 * A powerful dynamic CRUD API engine that automatically generates RESTful endpoints for your data models SWAIN provides automatic CRUD operations, filtering, pagination, and sorting capabilities for any data model. Features: - Automatic REST API generation - Dynamic model support - Complex filtering and querying - Pagination and sorting - Swagger/OpenAPI documentation - Multiple database support (SQL & NoSQL)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiErrorResponse,
  ApiFilterPayload,
  ApiSuccessResponse,
  ApiUpdateFilterPayload,
  QueryFilter,
  QueryFilterResponse,
} from '../models/index';
import {
    ApiErrorResponseFromJSON,
    ApiErrorResponseToJSON,
    ApiFilterPayloadFromJSON,
    ApiFilterPayloadToJSON,
    QueryFilterFromJSON,
    QueryFilterToJSON,
    QueryFilterResponseFromJSON,
    QueryFilterResponseToJSON,
    ApiSuccessResponseFromJSON,
    ApiUpdateFilterPayloadToJSON,
} from '../models/index';

import * as WebSocket from 'ws';
export interface ModelCountPostRequest {
    model: string;
    filter?: ApiFilterPayload;
}

export interface ModelFilterPostRequest {
    model: string;
    filter: QueryFilter;
    page?: number;
    pageSize?: number;
}

export interface ModelGetRequest {
    model: string;
    page?: number;
    pageSize?: number;
}

export interface ModelIdDeleteRequest {
    model: string;
    id: string;
}

export interface ModelIdGetRequest {
    model: string;
    id: string;
}

export interface ModelIdPutRequest {
    model: string;
    id: string;
    entity: object;
}

export interface ModelPostRequest {
    model: string;
    entity: object;
}

export interface ModelFilterDeleteRequest {
    model: string;
    filter: ApiFilterPayload;
}

export interface ModelFilterPutRequest {
    model: string;
    filter: ApiUpdateFilterPayload;
}

/**
 * 
 */
export class DynamicApi extends runtime.BaseAPI {

  /**
   * Add websocket support to the API for real-time updates and notifications. This allows clients to subscribe to changes in data models and receive updates in real-time.
   */

 private wsConnections: { [key: string]: WebSocket } = {};
    
    private async connectWebSocket(model: string, event: string, callback: (event: string, model: string, data: any) => void) {
        const wsUrl = `${this.configuration.basePath.replace('http', 'ws')}/ws/${model}/${event}`;
        const apiKeyFunction = this.configuration.apiKey;
        let apiKey: string | undefined;
        
        if (apiKeyFunction) {
            apiKey = await apiKeyFunction('api_key'); 
        }
        const ws = new WebSocket(wsUrl, [], {
            headers: {
               'X-API-KEY': apiKey || '',
            }
        });
  
        ws.on('open', () => {
        });

        ws.on('message', (message) => {
            const parsedMessage = JSON.parse(message.toString());
            callback(parsedMessage.event, parsedMessage.model, parsedMessage.data);
        });

        ws.on('close', () => {
            console.log(`WebSocket connection for ${model} ${event} events closed`);
        });

        ws.on('error', (error) => {
            console.error(`WebSocket error for ${model} ${event} events:`, error);
        });

        this.wsConnections[`${model}-${event}`] = ws;
    }

    public Listen(model: string, event: string, callback: (event: string, model :string,data:any ) => void) {
        this.connectWebSocket(model, event,callback);
    }

  

    public closeWebSocketConnections() {
        Object.values(this.wsConnections).forEach(ws => ws.close());
        this.wsConnections = {};
    }


   /**
    * Bulk operations for dynamic models
    */

 async modelFilterDeleteRaw(requestParameters: ModelFilterDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiSuccessResponse>> {
        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling modelFilterDelete().'
            );
        }

        if (requestParameters['filter'] == null) {
            throw new runtime.RequiredError(
                'filter',
                'Required parameter "filter" was null or undefined when calling modelFilterDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/{model}/filter`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters['model']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: ApiFilterPayloadToJSON(requestParameters['filter']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiSuccessResponseFromJSON(jsonValue));
    }

    /**
     * Delete multiple entities that match the given filter criteria. This operation allows deleting multiple records in a single request.
     * Mass delete entities by filter
     */
    async DeleteWhere(requestParameters: ModelFilterDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiSuccessResponse> {
        const response = await this.modelFilterDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Perform bulk updates on multiple entities that match the given filter criteria. This operation allows updating multiple records in a single request.
     * Mass update entities by filter
     */
    async modelFilterPutRaw(requestParameters: ModelFilterPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiSuccessResponse>> {
        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling modelFilterPut().'
            );
        }

        if (requestParameters['filter'] == null) {
            throw new runtime.RequiredError(
                'filter',
                'Required parameter "filter" was null or undefined when calling modelFilterPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/{model}/filter`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters['model']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ApiUpdateFilterPayloadToJSON(requestParameters['filter']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiSuccessResponseFromJSON(jsonValue));
    }

    /**
     * Perform bulk updates on multiple entities that match the given filter criteria. This operation allows updating multiple records in a single request.
     * Mass update entities by filter
     */
    async UpdateWhere(requestParameters: ModelFilterPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiSuccessResponse> {
        const response = await this.modelFilterPutRaw(requestParameters, initOverrides);
        return await response.value();
    }


    /**
     * Count entities that match the given filter criteria.
     * Count entities by filter
     */
    async modelCountPostRaw(requestParameters: ModelCountPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: any; }>> {
        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling modelCountPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/{model}/count`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters['model']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ApiFilterPayloadToJSON(requestParameters['filter']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Count entities that match the given filter criteria.
     * Count entities by filter
     */
    async Count(requestParameters: ModelCountPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: any; }> {
        const response = await this.modelCountPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Filter entities using complex conditions in the request body, including field expressions, logical operations, and relationship filtering
     * Filter entities
     */
    async modelFilterPostRaw(requestParameters: ModelFilterPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryFilterResponse>> {
        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling modelFilterPost().'
            );
        }

        if (requestParameters['filter'] == null) {
            throw new runtime.RequiredError(
                'filter',
                'Required parameter "filter" was null or undefined when calling modelFilterPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/{model}/filter`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters['model']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QueryFilterToJSON(requestParameters['filter']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QueryFilterResponseFromJSON(jsonValue));
    }

    /**
     * Filter entities using complex conditions in the request body, including field expressions, logical operations, and relationship filtering
     * Filter entities
     */
    async GetWhere(requestParameters: ModelFilterPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryFilterResponse> {
        const response = await this.modelFilterPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of entities. Supports pagination and sorting.
     * List entities
     */
    async modelGetRaw(requestParameters: ModelGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryFilterResponse>> {
        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling modelGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['pageSize'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters['model']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QueryFilterResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of entities. Supports pagination and sorting.
     * List entities
     */
    async GetAll(requestParameters: ModelGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryFilterResponse> {
        const response = await this.modelGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an entity by its ID
     * Delete an entity
     */
    async modelIdDeleteRaw(requestParameters: ModelIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling modelIdDelete().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling modelIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/{model}/{id}`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters['model']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete an entity by its ID
     * Delete an entity
     */
    async DeleteById(requestParameters: ModelIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.modelIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a single entity by its ID
     * Get an entity by ID
     */
    async modelIdGetRaw(requestParameters: ModelIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling modelIdGet().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling modelIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/{model}/{id}`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters['model']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Retrieve a single entity by its ID
     * Get an entity by ID
     */
    async GetById(requestParameters: ModelIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.modelIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing entity by its ID
     * Update an entity
     */
    async modelIdPutRaw(requestParameters: ModelIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling modelIdPut().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling modelIdPut().'
            );
        }

        if (requestParameters['entity'] == null) {
            throw new runtime.RequiredError(
                'entity',
                'Required parameter "entity" was null or undefined when calling modelIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/{model}/{id}`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters['model']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['entity'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Update an existing entity by its ID
     * Update an entity
     */
    async UpdateById(requestParameters: ModelIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.modelIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new entity of the specified model type
     * Create a new entity
     */
    async modelPostRaw(requestParameters: ModelPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling modelPost().'
            );
        }

        if (requestParameters['entity'] == null) {
            throw new runtime.RequiredError(
                'entity',
                'Required parameter "entity" was null or undefined when calling modelPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters['model']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['entity'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Create a new entity of the specified model type
     * Create a new entity
     */
    async Create(requestParameters: ModelPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.modelPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
